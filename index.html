<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>parkour</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1e1e2f; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 8px;
            pointer-events: none; border: 1px solid #555;
        }
        #center-dot {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: white; border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #checkpoint-msg {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            color: #10b981; font-size: 2rem; font-weight: bold; font-family: monospace;
            text-shadow: 2px 2px 0 #000; display: none; pointer-events: none;
        }
        .highlight { color: #facc15; font-weight: bold; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui">
        <h2 style="margin: 0 0 10px 0; color: #38bdf8;">Parkour Flow</h2>
        <p><span class="highlight">W A S D</span> : Move / Strafe</p>
        <p><span class="highlight">CTRL</span> : Sprint</p>
        <p><span class="highlight">SPACE</span> : Jump</p>
        <p><span class="highlight">ARROW KEYS</span> : Look Around</p>
        <hr style="border-color: #555;">
        <p>Green platforms = <span class="highlight">Checkpoints</span></p>
    </div>

    <div id="center-dot"></div>
    <div id="checkpoint-msg">CHECKPOINT REACHED!</div>

    <script>
        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1e1e2f);
        scene.fog = new THREE.Fog(0x1e1e2f, 10, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- 2. PLAYER & PHYSICS STATE ---
        const player = {
            pos: new THREE.Vector3(0, 5, 0),
            vel: new THREE.Vector3(0, 0, 0),
            size: new THREE.Vector3(0.8, 1.8, 0.8), 
            isGrounded: false,
            yaw: 0,   
            pitch: 0  
        };

        const physics = {
            gravity: 0.012,
            jumpPower: 0.28,
            baseSpeed: 0.14,  // Slightly faster base speed
            sprintMult: 1.6,  // 60% faster when holding CTRL
            friction: 0.8,
            airControl: 0.85  // MUCH higher air control so you can steer mid-air easily
        };

        let currentCheckpoint = new THREE.Vector3(0, 5, 0);

        // --- 3. INPUT HANDLING ---
        const keys = {};
        window.addEventListener('keydown', e => { 
            keys[e.code] = true; 
            // Prevent spacebar and arrows from scrolling the page
            if(["Space", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].indexOf(e.code) > -1) {
                e.preventDefault();
            }
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        // --- 4. EASIER LEVEL GENERATOR ---
        const platforms = []; 
        const hitboxes = [];  
        let platformIndex = 0;
        let lastPos = new THREE.Vector3(0, 0, 0);

        const blockGeo = new THREE.BoxGeometry(1, 1, 1);
        const cpMat = new THREE.MeshLambertMaterial({ color: 0x10b981 }); 

        function createBlock(x, y, z, w, h, d, material, isCheckpoint = false) {
            const mesh = new THREE.Mesh(blockGeo, material);
            mesh.scale.set(w, h, d);
            mesh.position.set(x, y, z);
            scene.add(mesh);
            platforms.push(mesh);

            const box = new THREE.Box3().setFromObject(mesh);
            hitboxes.push(box);

            if (isCheckpoint) {
                mesh.userData.isCheckpoint = true;
                mesh.userData.cpPos = new THREE.Vector3(x, y + h/2 + 2, z);
            }
        }

        function generateNextPlatform() {
            platformIndex++;
            
            // EASIER GAPS: Shorter distances and less extreme height changes
            let gapZ = 2.5 + Math.random() * 2.0; 
            let gapX = (Math.random() - 0.5) * 2.5; 
            let gapY = (Math.random() - 0.5) * 1.5; 

            // Prevent unfair upward jumps
            if (gapY > 1.0) gapY = 1.0; 
            if (gapY < -1.5) gapY = -1.5;

            lastPos.x += gapX;
            lastPos.y += gapY;
            lastPos.z -= gapZ; 

            let typeRoll = Math.random();
            let isCp = (platformIndex % 10 === 0); 
            
            let color = new THREE.Color().setHSL(Math.random(), 0.8, 0.5);
            let mat = isCp ? cpMat : new THREE.MeshLambertMaterial({ color: color });

            // EASIER PLATFORMS: Wider and deeper
            let platW = isCp ? 5 : 3 + Math.random() * 2;
            let platD = isCp ? 5 : 3 + Math.random() * 2;

            createBlock(lastPos.x, lastPos.y, lastPos.z, platW, 0.5, platD, mat, isCp);

            if (!isCp) {
                if (typeRoll < 0.15) {
                    // Headhitter (slightly higher clearance so it's less punishing)
                    createBlock(lastPos.x, lastPos.y + 2.6, lastPos.z, platW, 0.5, platD, mat);
                } else if (typeRoll < 0.3) {
                    // Neo (thinner wall so it's easier to strafe around)
                    createBlock(lastPos.x, lastPos.y + 2, lastPos.z + platD/2 + 0.5, 2.5, 4, 0.5, mat);
                }
            }
        }

        createBlock(0, 0, 0, 6, 0.5, 6, cpMat, true);
        for(let i=0; i<15; i++) generateNextPlatform();

        function showCheckpointUI() {
            const msg = document.getElementById('checkpoint-msg');
            msg.style.display = 'block';
            setTimeout(() => { msg.style.display = 'none'; }, 1500);
        }

        // --- 5. CUSTOM HITBOX COLLISION SYSTEM ---
        const playerBox = new THREE.Box3();
        
        function updatePlayerHitbox(offsetX = 0, offsetY = 0, offsetZ = 0) {
            playerBox.min.set(player.pos.x - player.size.x/2 + offsetX, player.pos.y + offsetY, player.pos.z - player.size.z/2 + offsetZ);
            playerBox.max.set(player.pos.x + player.size.x/2 + offsetX, player.pos.y + player.size.y + offsetY, player.pos.z + player.size.z/2 + offsetZ);
        }

        function checkCollisions() {
            for (let i = 0; i < hitboxes.length; i++) {
                if (playerBox.intersectsBox(hitboxes[i])) {
                    if (platforms[i].userData.isCheckpoint) {
                        if (currentCheckpoint.distanceTo(platforms[i].userData.cpPos) > 1) {
                            currentCheckpoint.copy(platforms[i].userData.cpPos);
                            showCheckpointUI();
                        }
                    }
                    return true;
                }
            }
            return false;
        }

        function die() {
            player.pos.copy(currentCheckpoint);
            player.vel.set(0,0,0);
            player.yaw = 0;
            player.pitch = 0;
        }

        // --- 6. MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // JUMP LOGIC (Moved here for better simultaneous key presses)
            // Using auto-bunnyhop logic: holding space while grounded jumps immediately
            if (keys['Space'] && player.isGrounded) {
                player.vel.y = physics.jumpPower;
                player.isGrounded = false;
            }

            // CAMERA CONTROLS
            if (keys['ArrowLeft']) player.yaw += 0.04;
            if (keys['ArrowRight']) player.yaw -= 0.04;
            if (keys['ArrowUp']) player.pitch += 0.04;
            if (keys['ArrowDown']) player.pitch -= 0.04;
            
            player.pitch = Math.max(-Math.PI/2.1, Math.min(Math.PI/2.1, player.pitch));

            // MOVEMENT INTENT 
            let moveX = 0; let moveZ = 0;
            if (keys['KeyW']) moveZ -= 1;
            if (keys['KeyS']) moveZ += 1;
            if (keys['KeyA']) moveX -= 1;
            if (keys['KeyD']) moveX += 1;

            if (moveX !== 0 || moveZ !== 0) {
                let length = Math.sqrt(moveX*moveX + moveZ*moveZ);
                moveX /= length; moveZ /= length;
            }

            // SPRINT CHECK
            let currentSpeed = physics.baseSpeed;
            if (keys['ControlLeft'] || keys['ControlRight']) {
                currentSpeed *= physics.sprintMult;
            }

            let sinY = Math.sin(player.yaw);
            let cosY = Math.cos(player.yaw);
            
            let targetVx = (moveX * cosY + moveZ * sinY) * currentSpeed;
            let targetVz = (-moveX * sinY + moveZ * cosY) * currentSpeed;

            let control = player.isGrounded ? 1 : physics.airControl;
            player.vel.x += (targetVx - player.vel.x) * 0.2 * control;
            player.vel.z += (targetVz - player.vel.z) * 0.2 * control;

            player.vel.y -= physics.gravity;

            // --- COLLISION RESOLUTION ---
            player.isGrounded = false;

            updatePlayerHitbox(player.vel.x, 0, 0);
            if (checkCollisions()) player.vel.x = 0; 
            else player.pos.x += player.vel.x;

            updatePlayerHitbox(0, player.vel.y, 0);
            if (checkCollisions()) {
                if (player.vel.y < 0) player.isGrounded = true; 
                player.vel.y = 0; 
            } else player.pos.y += player.vel.y;

            updatePlayerHitbox(0, 0, player.vel.z);
            if (checkCollisions()) player.vel.z = 0; 
            else player.pos.z += player.vel.z;

            // --- UPDATE CAMERA ---
            camera.position.set(player.pos.x, player.pos.y + player.size.y - 0.2, player.pos.z);
            camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');

            // --- DEATH & CHUNK LOADING ---
            if (player.pos.y < -15) die();

            if (player.pos.z < platforms[platforms.length - 5].position.z) {
                for(let i=0; i<5; i++) generateNextPlatform();
                
                while(platforms.length > 30) {
                    let oldMesh = platforms.shift();
                    scene.remove(oldMesh);
                    hitboxes.shift();
                }
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
