<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dsim</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0, 0, 0, 0.8); padding: 15px; border-radius: 8px;
            pointer-events: none; border: 1px solid #333;
        }
        #hud {
            position: absolute; bottom: 30px; right: 30px; color: #10b981;
            background: rgba(0, 0, 0, 0.9); padding: 15px 25px; border-radius: 8px;
            font-size: 1.5rem; font-family: monospace; text-align: right; border: 2px solid #333;
        }
        .hud-line { margin: 5px 0; }
        .warning { color: #ef4444; font-weight: bold; animation: blink 0.5s infinite; display: none; }
        .info { color: #fbbf24; font-size: 1rem; }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui">
        <h2 style="margin: 0 0 10px 0; color: #38bdf8;">Night Drive</h2>
        <p><b>W / S</b> : Gas / Brake (Reverse)</p>
        <p><b>A / D</b> : Steer</p>
        <hr style="border-color: #333;">
        <p class="info">RULES OF THE ROAD:</p>
        <p>- Speed Limit: 45 mph</p>
        <p>- Stay on the paved roads</p>
        <p>- Avoid collisions</p>
    </div>

    <div id="hud">
        <div id="ruleWarning" class="warning">VIOLATION</div>
        <div class="hud-line" id="speedometer">Speed: 0 mph</div>
        <div class="hud-line info">Limit: 45 mph</div>
    </div>

    <script>
        // --- 1. SETUP (Night Mode) ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510); // Deep night sky
        scene.fog = new THREE.FogExp2(0x050510, 0.003); // Thick night fog

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Dim ambient light (moonlight)
        const ambientLight = new THREE.AmbientLight(0x202040, 0.6);
        scene.add(ambientLight);

        // --- 2. PROCEDURAL TEXTURES (Glowing Windows) ---
        function createBuildingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#0a0a1a'; ctx.fillRect(0, 0, 256, 512); // Dark building
            
            // Draw glowing windows
            for(let y = 20; y < 500; y += 20) {
                for(let x = 20; x < 240; x += 20) {
                    if(Math.random() > 0.6) { // 40% chance of light being on
                        ctx.fillStyle = Math.random() > 0.2 ? '#fef08a' : '#93c5fd'; // Yellow or blue tint
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = ctx.fillStyle;
                        ctx.fillRect(x, y, 10, 12); 
                        ctx.shadowBlur = 0; // Reset for performance
                    }
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }
        const buildingMat = new THREE.MeshPhongMaterial({ map: createBuildingTexture(), shininess: 10 });

        // --- 3. CITY GRID ENVIRONMENT ---
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(2000, 2000), 
            new THREE.MeshLambertMaterial({ color: 0x0f172a }) // Dark grass/dirt
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const roadWidth = 30;
        const blockSize = 120;
        const citySize = 10; // 10x10 blocks

        // Roads Material
        const roadMat = new THREE.MeshLambertMaterial({ color: 0x1e293b });
        const lineMat = new THREE.MeshBasicMaterial({ color: 0xfbbf24 }); // Yellow lines

        const buildings = [];
        
        // Build Grid
        for (let x = -citySize; x <= citySize; x++) {
            for (let z = -citySize; z <= citySize; z++) {
                
                let posX = x * blockSize;
                let posZ = z * blockSize;

                // Create Roads (Horizontal and Vertical)
                if (z === 0) {
                    let hRoad = new THREE.Mesh(new THREE.PlaneGeometry(blockSize, roadWidth), roadMat);
                    hRoad.rotation.x = -Math.PI / 2; hRoad.position.set(posX, 0.1, posZ); hRoad.receiveShadow = true;
                    scene.add(hRoad);
                }
                if (x === 0) {
                    let vRoad = new THREE.Mesh(new THREE.PlaneGeometry(roadWidth, blockSize), roadMat);
                    vRoad.rotation.x = -Math.PI / 2; vRoad.position.set(posX, 0.1, posZ); vRoad.receiveShadow = true;
                    scene.add(vRoad);
                }

                // Create Buildings in the blocks (skip the intersections)
                if (x !== 0 && z !== 0) {
                    // 4 buildings per block
                    for(let b = 0; b < 4; b++) {
                        let w = 20 + Math.random() * 20;
                        let d = 20 + Math.random() * 20;
                        let h = 40 + Math.random() * 100;
                        
                        let bX = posX + (b%2 === 0 ? 25 : -25);
                        let bZ = posZ + (b < 2 ? 25 : -25);

                        const building = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), buildingMat);
                        building.position.set(bX, h/2, bZ);
                        building.castShadow = true; building.receiveShadow = true;
                        
                        buildingMat.map.repeat.set(w/40, h/40); // Scale texture
                        scene.add(building);
                        buildings.push(building);
                    }
                }
            }
        }

        // --- 4. PLAYER CAR BUILDER ---
        function createCar(colorHex, isPlayer) {
            const carGroup = new THREE.Group();
            
            // Chassis
            const chassis = new THREE.Mesh(new THREE.BoxGeometry(4, 1.2, 9), new THREE.MeshPhongMaterial({ color: colorHex }));
            chassis.position.y = 1; chassis.castShadow = true;
            carGroup.add(chassis);

            // Cabin
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(3.6, 1.5, 5), new THREE.MeshPhongMaterial({ color: 0x111111, shininess: 100 }));
            cabin.position.set(0, 2.3, -0.5); cabin.castShadow = true;
            carGroup.add(cabin);

            // Taillights
            const tailGeo = new THREE.BoxGeometry(1, 0.4, 0.2);
            const tailMat = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Emissive red
            const tailL = new THREE.Mesh(tailGeo, tailMat); tailL.position.set(-1.5, 1.2, 4.6);
            const tailR = new THREE.Mesh(tailGeo, tailMat); tailR.position.set(1.5, 1.2, 4.6);
            carGroup.add(tailL, tailR);

            // Headlights (Only for player to save performance)
            if (isPlayer) {
                const headMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const headL = new THREE.Mesh(tailGeo, headMat); headL.position.set(-1.5, 1.2, -4.6);
                const headR = new THREE.Mesh(tailGeo, headMat); headR.position.set(1.5, 1.2, -4.6);
                carGroup.add(headL, headR);

                // Actual Light Beams
                function addSpotlight(x) {
                    const spot = new THREE.SpotLight(0xffffee, 2, 200, Math.PI/5, 0.5, 1);
                    spot.position.set(x, 1.5, -4);
                    spot.target.position.set(x, 0, -50);
                    spot.castShadow = true;
                    carGroup.add(spot);
                    carGroup.add(spot.target);
                }
                addSpotlight(-1.5);
                addSpotlight(1.5);
            }

            return carGroup;
        }

        const playerCar = createCar(0x3b82f6, true); // Blue player car
        scene.add(playerCar);

        // --- 5. TRAFFIC SYSTEM ---
        const trafficCars = [];
        const colors = [0xff0000, 0x10b981, 0xf59e0b, 0xffffff, 0x6b7280];
        
        for(let i=0; i<30; i++) {
            let tCar = createCar(colors[Math.floor(Math.random() * colors.length)], false);
            
            // Put them randomly on the main horizontal or vertical roads
            let isHorizontal = Math.random() > 0.5;
            let laneOffset = Math.random() > 0.5 ? 7 : -7; // Drive on right side
            
            if(isHorizontal) {
                tCar.position.set((Math.random() - 0.5) * 1500, 0, laneOffset);
                tCar.rotation.y = laneOffset > 0 ? -Math.PI/2 : Math.PI/2;
            } else {
                tCar.position.set(laneOffset, 0, (Math.random() - 0.5) * 1500);
                tCar.rotation.y = laneOffset > 0 ? 0 : Math.PI;
            }
            
            tCar.userData = { speed: 0.3 + Math.random() * 0.4 };
            scene.add(tCar);
            trafficCars.push(tCar);
        }

        // --- 6. PHYSICS & RULES STATE ---
        let speed = 0;
        const maxSpeed = 1.2; // approx 80 mph
        const acceleration = 0.015;
        const braking = 0.03;
        const turnSpeed = 0.04;
        let warningTimer = 0;

        function showWarning(text) {
            const w = document.getElementById('ruleWarning');
            w.innerText = text;
            w.style.display = 'block';
            warningTimer = 60; // frames
        }

        // Starting position
        playerCar.position.set(7, 0, 0); 

        // --- 7. INPUTS ---
        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        // --- 8. MAIN LOOP ---
        const carBox = new THREE.Box3();
        const obstacleBox = new THREE.Box3();

        function animate() {
            requestAnimationFrame(animate);

            // Throttle & Brake
            if (keys['KeyW']) speed += acceleration;
            if (keys['KeyS']) speed -= braking; 
            
            // Natural friction
            if (!keys['KeyW'] && !keys['KeyS']) speed *= 0.98; 
            
            // Hard speed limits
            speed = Math.max(-0.3, Math.min(maxSpeed, speed)); 

            // Steering (Only turn if moving)
            if (Math.abs(speed) > 0.05) {
                let turningFactor = turnSpeed * (speed > 0 ? 1 : -1); // Reverse steering
                if (keys['KeyA']) playerCar.rotation.y += turningFactor;  
                if (keys['KeyD']) playerCar.rotation.y -= turningFactor; 
            }

            // Movement
            playerCar.position.x -= Math.sin(playerCar.rotation.y) * speed;
            playerCar.position.z -= Math.cos(playerCar.rotation.y) * speed;

            // --- TRAFFIC MOVEMENT ---
            trafficCars.forEach(car => {
                car.position.x -= Math.sin(car.rotation.y) * car.userData.speed;
                car.position.z -= Math.cos(car.rotation.y) * car.userData.speed;
                
                // Wrap around city
                if(car.position.x > 1000) car.position.x = -1000;
                if(car.position.x < -1000) car.position.x = 1000;
                if(car.position.z > 1000) car.position.z = -1000;
                if(car.position.z < -1000) car.position.z = 1000;
            });

            // --- ROAD RULES & COLLISIONS ---
            let mph = Math.floor(Math.abs(speed) * 70);
            
            // Rule 1: Speeding
            if (mph > 45) {
                showWarning("SPEEDING!");
            }

            // Rule 2: Off-Road (Check if outside the road width grid)
            let onRoadX = Math.abs(playerCar.position.x % blockSize) < roadWidth/2 || Math.abs(playerCar.position.x % blockSize) > blockSize - roadWidth/2;
            let onRoadZ = Math.abs(playerCar.position.z % blockSize) < roadWidth/2 || Math.abs(playerCar.position.z % blockSize) > blockSize - roadWidth/2;
            
            if (!onRoadX && !onRoadZ) {
                showWarning("OFF ROAD!");
                speed *= 0.9; // Grass slows you down
            }

            // Collisions
            carBox.setFromObject(playerCar);
            
            // Hit Buildings
            for (let b of buildings) {
                obstacleBox.setFromObject(b);
                if (carBox.intersectsBox(obstacleBox)) {
                    showWarning("CRASH!");
                    speed = -speed * 0.5; // Bounce back
                }
            }
            
            // Hit Traffic
            for (let t of trafficCars) {
                obstacleBox.setFromObject(t);
                if (carBox.intersectsBox(obstacleBox)) {
                    showWarning("VEHICLE COLLISION!");
                    speed = -speed * 0.5; 
                }
            }

            // Warning UI Timer
            if(warningTimer > 0) {
                warningTimer--;
            } else {
                document.getElementById('ruleWarning').style.display = 'none';
            }

            // --- CAMERA ---
            // Chase camera setup
            const camOffset = new THREE.Vector3(0, 5, 12).applyMatrix4(playerCar.matrixWorld);
            camera.position.lerp(camOffset, 0.2); // Smooth follow
            
            // Look slightly ahead of the car
            const lookTarget = new THREE.Vector3(0, 0, -10).applyMatrix4(playerCar.matrixWorld);
            camera.lookAt(lookTarget);

            // Update UI
            document.getElementById('speedometer').innerText = `Speed: ${mph} mph`;

            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
